#ifndef VECS_SHARE_H
#define VECS_SHARE_H

#include "object.h"

// Allocate a new object of the given type.
//
// The caller is responsible for initializing the object's data fields.
//
// It is born in a "possibly dead" state and with a zero reference count,
// because nothing has stored a durable reference to it yet.
// All that exists in the program is the "in flight" reference that will
// be returned to the caller, which the program may choose to store one
// or more times in some durable place. But if that doesn't happen before
// the next reclaim phase (when all "in flight" references are gone),
// then the object will be cleaned up immediately in that reclamation.
// If instead it has gained a nonzero reference count in that time,
// it will be removed from the "possibly dead" list and will not return
// to it until its reference count drops to zero again.
vecs_object_t* vecs_share_alloc(const vecs_type_t* type);

// Increment the reference count of the given object.
//
// This should be called by the program (usually with a call site that
// was automatically generated by the compiler) to indicate that a reference
// to the given object has been stored somewhere durable (i.e. in a place
// that will outlive the next call to `vecs_share_reclaim_local_dead`).
void vecs_share_inc_ref(vecs_object_t* object);

// Decrement the reference count of the given object.
//
// This should be called by the program (usually with a call site that
// was automatically generated by the compiler) to indicate that a reference
// to the given object was removed from a previously-durable storage
// that corresponded to a prior call to `vecs_share_inc_ref`.
//
// If the reference count drops to zero, the object will be marked as
// "possibly dead" (if it wasn't already), being added to a list of the
// "possibly dead" so its reference count can be checked again
// during a reclaim phase. If it's still zero at that time, the object
// is considered no longer reachable by the program ("actually dead")
// and its memory will be reclaimable for future allocations.
void vecs_share_dec_ref(vecs_object_t* object);

// Run the reclaim phase for the current thread.
//
// For memory safety, this must only be done in a "stop the world" context,
// when no user-level code is running in any thread. Most particularly,
// it can only be run at a time when it is impossible to run functions like
// `vecs_share_dec_ref` or any function that calls it.
//
// It is allowed and desirable to run this in parallel across all threads.
void vecsint_share_reclaim_local_dead();

// Run the post-reclaim object finalizer phase for the current thread.
//
// For memory safety, this must only be done when the reclaim phase has
// completed in all threads, because finalizers can and often do call
// functions that are disallowed during the reclaim phase.
void vecsint_share_run_local_finalizers();

#endif
